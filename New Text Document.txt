import pomegranate as pom

# Create the network
model = pom.BayesianNetwork("Spam Filter")

# Define the nodes and their probability distributions
sender = pom.DiscreteDistribution({"spammer": 0.3, "legitimate": 0.7})
subject_line = pom.DiscreteDistribution({"spammy": 0.5, "legitimate": 0.5})
content = pom.DiscreteDistribution({"spammy": 0.8, "legitimate": 0.2})
spam = pom.ConditionalProbabilityTable(
    [[0, 0, 0, 1],
     [0, 0, 1, 0],
     [0, 1, 0, 1],
     [0, 1, 1, 0],
     [1, 0, 0, 0],
     [1, 0, 1, 1],
     [1, 1, 0, 0],
     [1, 1, 1, 1]],
    [sender, subject_line, content])

# Add the nodes to the model
model.add_states(sender, subject_line, content, spam)
model.add_edge(sender, spam)
model.add_edge(subject_line, spam)
model.add_edge(content, spam)

# Train the model
model.fit([{"sender": "spammer", "subject_line": "spammy", "content": "spammy"},
           {"sender": "legitimate", "subject_line": "legitimate", "content": "legitimate"},
           {"sender": "legitimate", "subject_line": "spammy", "content": "legitimate"}])

# Classify a new email
email = {"sender": "spammer", "subject_line": "legitimate", "content": "spammy"}
prediction = model.predict_proba(email)
print(prediction)

==============================================================================================================
Using pgmpy 
==============================================================================================================

from pgmpy.models import BayesianModel
from pgmpy.estimators import MaximumLikelihoodEstimator
import pandas as pd
import numpy as np

# Load the data
data = pd.read_csv('email_data.csv')

# Extract the features and labels from the data
features = data.drop('label', axis=1)
labels = data['label']

# Convert the labels to a binary format (0 = non-spam, 1 = spam)
labels = np.where(labels == 'spam', 1, 0)

# Build the Bayesian network using pgmpy
model = BayesianModel()
for col in features:
    model.add_node(col)
model.add_node('label')

# Add edges between the features and label, representing the statistical relationships between them
for col in features:
    model.add_edge(col, 'label')

# Train the model using maximum likelihood estimation
estimator = MaximumLikelihoodEstimator(model, features, labels)
model.fit(features, estimator=estimator)

# Compute the posterior probabilities of the features and label
feature_posteriors = [model.predict_proba({col: 1})[0]['1'] for col in features]
label_posterior = model.predict_proba({'label': 1})[0]['1']

